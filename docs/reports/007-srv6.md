# Plan 007: SRv6 (Segment Routing over IPv6) Implementation Report

## Summary

Implemented SRv6 (Segment Routing over IPv6) support as specified in the plan. This enables source-routed paths using IPv6 addresses as segment identifiers, supporting both route encapsulation and local SID behaviors.

## Implementation Details

### Files Created

1. **`crates/nlink/src/netlink/types/srv6.rs`** (~150 lines)
   - Kernel structures for SRv6 operations using zerocopy
   - `Ipv6SrHdr` - Segment Routing Header (8 bytes)
   - Constants: `seg6_mode::*`, `seg6_iptunnel::*`, `seg6_local_action::*`, `seg6_local::*`
   - Flavor operations: `seg6_local_flv::*`, `seg6_local_flv_op::*`

2. **`crates/nlink/src/netlink/srv6.rs`** (~700 lines)
   - High-level types and builders:
     - `Srv6Mode` enum (Inline, Encap, L2Encap, EncapRed, L2EncapRed)
     - `Srv6Action` enum (End, EndX, EndT, EndDX2, EndDX4, EndDX6, EndDT4, EndDT6, EndDT46, EndB6, EndB6Encaps, EndBPF)
     - `Srv6Encap` builder for route encapsulation
     - `Srv6LocalRoute` parsed representation
     - `Srv6LocalBuilder` for local SID routes
   - Connection methods for `Connection<Route>`

### Files Modified

1. **`crates/nlink/src/netlink/types/mod.rs`**
   - Added `pub mod srv6;`

2. **`crates/nlink/src/netlink/mod.rs`**
   - Added `pub mod srv6;`

3. **`crates/nlink/src/netlink/route.rs`**
   - Added `srv6_encap` field to `Ipv4Route` and `Ipv6Route`
   - Added `srv6_encap()` method to both route builders
   - Updated `build()` to emit RTA_ENCAP_TYPE and RTA_ENCAP for SRv6

4. **`CLAUDE.md`**
   - Added srv6.rs to the module listing
   - Added comprehensive SRv6 usage examples

## API Surface

### Srv6Mode

```rust
pub enum Srv6Mode {
    Inline,      // Insert SRH into existing IPv6 packet
    Encap,       // Encapsulate in new IPv6 header with SRH
    L2Encap,     // Encapsulate L2 frame
    EncapRed,    // Encap with reduced SRH
    L2EncapRed,  // L2 encap with reduced SRH
}
```

### Srv6Encap (for IP routes)

```rust
Srv6Encap::encap()           // Encap mode (default)
    .segment(Ipv6Addr)       // Add single segment
    .segments(&[Ipv6Addr])   // Add multiple segments
    .mode(Srv6Mode)          // Set mode

Srv6Encap::inline()          // Inline mode (IPv6 only)
Srv6Encap::l2_encap()        // L2 encap mode
```

### Srv6LocalBuilder (for local SIDs)

```rust
// End actions (transit)
Srv6LocalBuilder::end(sid)
Srv6LocalBuilder::end_x(sid, nexthop)
Srv6LocalBuilder::end_t(sid, table)

// Decap actions
Srv6LocalBuilder::end_dx2(sid)                    // L2 decap
Srv6LocalBuilder::end_dx4(sid)                    // IPv4 decap
Srv6LocalBuilder::end_dx4_via(sid, nexthop)       // IPv4 decap with nexthop
Srv6LocalBuilder::end_dx6(sid)                    // IPv6 decap
Srv6LocalBuilder::end_dx6_via(sid, nexthop)       // IPv6 decap with nexthop
Srv6LocalBuilder::end_dt4(sid, table)             // IPv4 VRF lookup
Srv6LocalBuilder::end_dt6(sid, table)             // IPv6 VRF lookup
Srv6LocalBuilder::end_dt46(sid, table)            // IPv4/IPv6 VRF lookup

// Binding SID actions
Srv6LocalBuilder::end_b6(sid, &[segments])        // Insert SRH
Srv6LocalBuilder::end_b6_encaps(sid, &[segments]) // Encap with SRH

// Common methods
.dev("eth0")                  // Set output interface by name
.oif(ifindex)                 // Set output interface by index
```

### Connection Methods

```rust
// Query SRv6 local routes
conn.get_srv6_local_routes().await?;

// Manage SRv6 local routes
conn.add_srv6_local(builder).await?;
conn.replace_srv6_local(builder).await?;
conn.del_srv6_local(sid).await?;
```

### Route Integration

```rust
// IPv4 with SRv6 encapsulation
Ipv4Route::new("10.0.0.0", 8)
    .dev("eth0")
    .srv6_encap(Srv6Encap::encap().segment(sid))

// IPv6 with SRv6 inline mode
Ipv6Route::new("2001:db8::", 32)
    .dev("eth0")
    .srv6_encap(Srv6Encap::inline().segment(sid))
```

## SRv6 Header Format

The Segment Routing Header (SRH) is an IPv6 extension header:

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Next Header  |  Hdr Ext Len  | Routing Type=4| Segments Left |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| First Segment |     Flags     |              Tag              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|            Segment List[0] (128-bit IPv6 address)             |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|            Segment List[1] (128-bit IPv6 address)             |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                            ...                              //
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- Segments are stored in reverse order (last segment first in memory)
- `Segments Left` counts down as packets traverse the path
- `First Segment` is the index of the first (last in memory) segment

## Testing

- All existing tests pass
- Clippy passes with no warnings
- Added unit tests for:
  - `Srv6Mode` conversion
  - `Srv6Encap` building and SRH construction
  - `Srv6LocalBuilder` variants
  - `Srv6Action` naming

## Key Implementation Notes

1. **LWTUNNEL_ENCAP_SEG6 (5)**: Used for route encapsulation (push segments)

2. **LWTUNNEL_ENCAP_SEG6_LOCAL (7)**: Used for local SID behaviors

3. **SEG6_IPTUNNEL_SRH**: Contains mode (4 bytes) + SRH structure

4. **Segment ordering**: Segments are specified first-to-last but stored last-to-first in the SRH

5. **Mode in SRH data**: For SEG6_LOCAL_SRH, the mode is prepended as a 4-byte value

## Linux Kernel Requirements

- Linux 4.10+ for basic SRv6 support
- Linux 4.14+ for End.DT4/DT6
- Linux 5.14+ for End.DT46

### Prerequisites

```bash
# Enable SRv6 globally
sudo sysctl -w net.ipv6.conf.all.seg6_enabled=1

# Enable SRv6 on specific interfaces
sudo sysctl -w net.ipv6.conf.eth0.seg6_enabled=1
```

## Example Usage

```rust
use nlink::netlink::{Connection, Route};
use nlink::netlink::srv6::{Srv6Encap, Srv6LocalBuilder};
use nlink::netlink::route::Ipv4Route;

let conn = Connection::<Route>::new()?;

// Add SRv6 encapsulation route (IPv4 over SRv6)
conn.add_route(
    Ipv4Route::new("10.0.0.0", 8)
        .dev("eth0")
        .srv6_encap(
            Srv6Encap::encap()
                .segment("fc00:1::1".parse()?)
        )
).await?;

// Add End.DT4 local SID (decap to VRF)
conn.add_srv6_local(
    Srv6LocalBuilder::end_dt4("fc00:1::100".parse()?, 254)
        .dev("eth0")
).await?;

// List SRv6 local routes
for route in conn.get_srv6_local_routes().await? {
    println!("{:?}: {}", route.sid, route.action.name());
}

// Cleanup
conn.del_srv6_local("fc00:1::100".parse()?).await?;
```

## Future Work

- SRv6 with HMAC verification
- SRv6 Policy (multiple color/endpoint combinations)
- uSID (micro-SID) support
- SRv6 counters and statistics
- Integration with VRF for L3VPN
