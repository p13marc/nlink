# Plan 007: Segment Routing IPv6 (SRv6)

## Overview

Add support for SRv6 (Segment Routing over IPv6), enabling source-routed paths using IPv6 addresses as segment identifiers.

## Motivation

SRv6 is the modern approach to traffic engineering in IPv6 networks:

1. **Source routing**: Path encoded in packet header
2. **Network programming**: SRv6 functions (End, End.X, End.DT4, etc.)
3. **Simplified control plane**: No per-hop state needed
4. **VPN services**: SRv6-based L3VPN and EVPN
5. **Service chaining**: Steering traffic through network functions

SRv6 is replacing MPLS in many next-generation networks.

## Design

### API Design

```rust
/// SRv6 segment (128-bit IPv6 address).
pub type Srv6Segment = Ipv6Addr;

/// SRv6 encapsulation modes.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Srv6Mode {
    /// Inline mode: insert SRH into existing IPv6 packet
    Inline,
    /// Encap mode: encapsulate in new IPv6 header with SRH
    Encap,
    /// L2 encap: encapsulate L2 frame
    L2Encap,
}

/// SRv6 encapsulation for routes.
#[derive(Debug, Clone)]
pub struct Srv6Encap {
    /// Encapsulation mode
    mode: Srv6Mode,
    /// Segment list (first = final destination)
    segments: Vec<Srv6Segment>,
}

impl Srv6Encap {
    pub fn encap() -> Self;
    pub fn inline() -> Self;
    pub fn segments(self, segs: &[Ipv6Addr]) -> Self;
    pub fn segment(self, seg: Ipv6Addr) -> Self;
}

/// SRv6 local action types.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Srv6Action {
    /// End: regular SID, pop and continue
    End,
    /// End.X: pop and forward to specific nexthop
    EndX,
    /// End.T: pop and lookup in specific table
    EndT,
    /// End.DX2: decap and forward L2 frame
    EndDX2,
    /// End.DX4: decap and forward IPv4 packet
    EndDX4,
    /// End.DX6: decap and forward IPv6 packet
    EndDX6,
    /// End.DT4: decap and lookup IPv4 in table
    EndDT4,
    /// End.DT6: decap and lookup IPv6 in table
    EndDT6,
    /// End.B6: insert SRH and forward
    EndB6,
    /// End.B6.Encaps: encap with new header and SRH
    EndB6Encaps,
}

/// SRv6 local route (segment endpoint behavior).
#[derive(Debug, Clone)]
pub struct Srv6LocalRoute {
    /// Local SID (segment identifier)
    sid: Ipv6Addr,
    /// Action to perform
    action: Srv6Action,
    /// Table for End.T/End.DT* actions
    table: Option<u32>,
    /// Nexthop for End.X action
    nexthop: Option<Ipv6Addr>,
    /// Output interface for End.X/End.DX* actions
    oif: Option<u32>,
    /// VRF for End.DT* actions
    vrf: Option<String>,
    /// Encapsulation for End.B6* actions
    srh: Option<Vec<Ipv6Addr>>,
}

/// Builder for SRv6 local routes.
#[derive(Debug, Clone)]
pub struct Srv6LocalBuilder {
    sid: Ipv6Addr,
    action: Srv6Action,
    table: Option<u32>,
    nexthop: Option<Ipv6Addr>,
    dev: Option<String>,
    oif: Option<u32>,
    srh: Option<Vec<Ipv6Addr>>,
}

impl Srv6LocalBuilder {
    /// End action: pop and continue lookup.
    pub fn end(sid: Ipv6Addr) -> Self;
    
    /// End.X action: pop and forward to nexthop.
    pub fn end_x(sid: Ipv6Addr, nexthop: Ipv6Addr) -> Self;
    
    /// End.T action: pop and lookup in table.
    pub fn end_t(sid: Ipv6Addr, table: u32) -> Self;
    
    /// End.DX4 action: decap and forward IPv4.
    pub fn end_dx4(sid: Ipv6Addr) -> Self;
    
    /// End.DX6 action: decap and forward IPv6.
    pub fn end_dx6(sid: Ipv6Addr) -> Self;
    
    /// End.DT4 action: decap and lookup IPv4 in table.
    pub fn end_dt4(sid: Ipv6Addr, table: u32) -> Self;
    
    /// End.DT6 action: decap and lookup IPv6 in table.
    pub fn end_dt6(sid: Ipv6Addr, table: u32) -> Self;
    
    /// End.B6.Encaps action: encap with SRH.
    pub fn end_b6_encaps(sid: Ipv6Addr, segments: &[Ipv6Addr]) -> Self;
    
    /// Set output device.
    pub fn dev(self, dev: impl Into<String>) -> Self;
    
    /// Set output interface index.
    pub fn oif(self, oif: u32) -> Self;
}

// Extend existing route builders
impl Ipv4Route {
    /// Add SRv6 encapsulation.
    pub fn srv6_encap(self, encap: Srv6Encap) -> Self;
}

impl Ipv6Route {
    /// Add SRv6 encapsulation.
    pub fn srv6_encap(self, encap: Srv6Encap) -> Self;
}

impl Connection<Route> {
    /// Get SRv6 local routes.
    pub async fn get_srv6_local_routes(&self) -> Result<Vec<Srv6LocalRoute>>;
    
    /// Add SRv6 local route.
    pub async fn add_srv6_local(&self, builder: Srv6LocalBuilder) -> Result<()>;
    
    /// Delete SRv6 local route.
    pub async fn del_srv6_local(&self, sid: Ipv6Addr) -> Result<()>;
}
```

### Usage Example

```rust
use nlink::netlink::{Connection, Route};
use nlink::netlink::srv6::{Srv6Encap, Srv6LocalBuilder, Srv6Mode};
use nlink::netlink::route::{Ipv4Route, Ipv6Route};
use std::net::Ipv6Addr;

let conn = Connection::<Route>::new()?;

// IPv4 route with SRv6 encapsulation (IPv4oIPv6)
conn.add_route(
    Ipv4Route::new("10.0.0.0", 8)
        .dev("eth0")
        .srv6_encap(
            Srv6Encap::encap()
                .segments(&[
                    "fc00:1::1".parse()?,  // First hop (final destination)
                    "fc00:2::1".parse()?,  // Intermediate
                ])
        )
).await?;

// IPv6 route with SRv6 encapsulation
conn.add_route(
    Ipv6Route::new("2001:db8::", 32)
        .srv6_encap(
            Srv6Encap::inline()
                .segment("fc00:1::1".parse()?)
        )
).await?;

// SRv6 End.DT4 (decap to VRF)
conn.add_srv6_local(
    Srv6LocalBuilder::end_dt4("fc00:1::100".parse()?, 100)
        .dev("eth0")
).await?;

// SRv6 End.X (pop and forward)
conn.add_srv6_local(
    Srv6LocalBuilder::end_x(
        "fc00:1::1".parse()?,
        "fe80::1".parse()?,
    ).dev("eth0")
).await?;

// SRv6 End (simple transit)
conn.add_srv6_local(
    Srv6LocalBuilder::end("fc00:1::2".parse()?)
        .dev("eth0")
).await?;
```

### Implementation Details

**Encapsulation types:**
- `LWTUNNEL_ENCAP_SEG6` (5): SRv6 encapsulation
- `LWTUNNEL_ENCAP_SEG6_LOCAL` (7): SRv6 local behavior

**Seg6 attributes (SEG6_IPTUNNEL_*):**
```c
enum {
    SEG6_IPTUNNEL_UNSPEC,
    SEG6_IPTUNNEL_SRH,  // Segment Routing Header
};
```

**Seg6 local attributes (SEG6_LOCAL_*):**
```c
enum {
    SEG6_LOCAL_UNSPEC,
    SEG6_LOCAL_ACTION,      // Srv6 action type
    SEG6_LOCAL_SRH,         // SRH for B6 actions
    SEG6_LOCAL_TABLE,       // Table for End.T/End.DT*
    SEG6_LOCAL_NH4,         // IPv4 nexthop for End.DX4
    SEG6_LOCAL_NH6,         // IPv6 nexthop for End.X/DX6
    SEG6_LOCAL_IIF,         // Input interface
    SEG6_LOCAL_OIF,         // Output interface
    SEG6_LOCAL_BPF,         // BPF program
    SEG6_LOCAL_VRFTABLE,    // VRF table
    // ... more
};
```

**SRH (Segment Routing Header) structure:**
```c
struct ipv6_sr_hdr {
    __u8 nexthdr;
    __u8 hdrlen;
    __u8 type;        // 4 = SRH
    __u8 segments_left;
    __u8 first_segment;
    __u8 flags;
    __u16 tag;
    struct in6_addr segments[0];  // Variable length
};
```

### File Changes

| File | Change |
|------|--------|
| `crates/nlink/src/netlink/srv6.rs` | New file: SRv6 types and builders |
| `crates/nlink/src/netlink/route.rs` | Add srv6_encap() to route builders |
| `crates/nlink/src/netlink/connection.rs` | Add SRv6 local route methods |
| `crates/nlink/src/netlink/types/srv6.rs` | SRv6 structures |
| `crates/nlink/src/netlink/mod.rs` | Export srv6 module |

## Implementation Steps

### Step 1: Add SRv6 types

```rust
// crates/nlink/src/netlink/types/srv6.rs

use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};

/// Segment Routing Header
#[repr(C, packed)]
#[derive(Debug, Clone, Copy, FromBytes, IntoBytes, Immutable, KnownLayout)]
pub struct Ipv6SrHdr {
    pub nexthdr: u8,
    pub hdrlen: u8,
    pub sr_type: u8,
    pub segments_left: u8,
    pub first_segment: u8,
    pub flags: u8,
    pub tag: u16,
    // Followed by segments array
}

/// SRv6 encapsulation mode
pub mod seg6_mode {
    pub const INLINE: u32 = 0;
    pub const ENCAP: u32 = 1;
    pub const L2ENCAP: u32 = 2;
}

/// Seg6 iptunnel attributes
pub mod seg6_iptunnel {
    pub const UNSPEC: u16 = 0;
    pub const SRH: u16 = 1;
}

/// Seg6 local action types
pub mod seg6_local_action {
    pub const END: u32 = 1;
    pub const END_X: u32 = 2;
    pub const END_T: u32 = 3;
    pub const END_DX2: u32 = 4;
    pub const END_DX6: u32 = 5;
    pub const END_DX4: u32 = 6;
    pub const END_DT6: u32 = 7;
    pub const END_DT4: u32 = 8;
    pub const END_B6: u32 = 9;
    pub const END_B6_ENCAPS: u32 = 10;
    pub const END_BM: u32 = 11;
    pub const END_S: u32 = 12;
    pub const END_AS: u32 = 13;
    pub const END_AM: u32 = 14;
    pub const END_BPF: u32 = 15;
    pub const END_DT46: u32 = 16;
}

/// Seg6 local attributes
pub mod seg6_local {
    pub const UNSPEC: u16 = 0;
    pub const ACTION: u16 = 1;
    pub const SRH: u16 = 2;
    pub const TABLE: u16 = 3;
    pub const NH4: u16 = 4;
    pub const NH6: u16 = 5;
    pub const IIF: u16 = 6;
    pub const OIF: u16 = 7;
    pub const BPF: u16 = 8;
    pub const VRFTABLE: u16 = 9;
    pub const COUNTERS: u16 = 10;
    pub const FLAVORS: u16 = 11;
}
```

### Step 2: Create srv6.rs module

Implement `Srv6Encap`, `Srv6LocalBuilder`, and related types.

### Step 3: Update route builders

Add `srv6_encap()` method similar to `mpls_encap()`.

### Step 4: Add Connection methods

Implement CRUD operations for SRv6 local routes.

## Testing

### Prerequisites

```bash
# Enable SRv6
sudo sysctl -w net.ipv6.conf.all.seg6_enabled=1
sudo sysctl -w net.ipv6.conf.eth0.seg6_enabled=1
```

### Example

```rust
//! Example: SRv6 routing

use nlink::netlink::{Connection, Route};
use nlink::netlink::srv6::{Srv6Encap, Srv6LocalBuilder};
use nlink::netlink::route::Ipv4Route;
use std::net::Ipv6Addr;

#[tokio::main]
async fn main() -> nlink::netlink::Result<()> {
    let conn = Connection::<Route>::new()?;
    
    // Add SRv6 encapsulation route
    conn.add_route(
        Ipv4Route::new("10.0.0.0", 8)
            .dev("lo")
            .srv6_encap(
                Srv6Encap::encap()
                    .segment("fc00:1::1".parse()?)
            )
    ).await?;
    
    // Add End.DT4 SID
    conn.add_srv6_local(
        Srv6LocalBuilder::end_dt4("fc00:1::100".parse()?, 254)
            .dev("lo")
    ).await?;
    
    // List SRv6 routes
    for route in conn.get_srv6_local_routes().await? {
        println!("{:?}", route);
    }
    
    Ok(())
}
```

## Documentation

Add SRv6 section to CLAUDE.md.

## Effort Estimate

- Implementation: ~12 hours
- Testing: ~3 hours
- Documentation: ~1 hour
- **Total: ~16 hours**

## Future Work

- SRv6 with HMAC verification
- SRv6 Policy (multiple color/endpoint combinations)
- uSID (micro-SID) support
- SRv6 counters and statistics
- Integration with VRF for L3VPN
